# Обзор архитектуры DrawZero

Этот документ обобщает внутреннюю структуру проекта DrawZero, чтобы контрибьюторы могли быстро сориентироваться в кодовой базе.

## Структура пакета

```
src/drawzero/
├── __init__.py          # Реэкспортированный публичный API
├── __main__.py          # Точка входа CLI (копирует примеры, рисует демонстрационный кадр)
├── examples/            # Скрипты в стиле туториалов, выполняемые тестами
└── utils/               # Основные утилиты для рендеринга, математики и удобства
```

Другие примечательные папки верхнего уровня:

* `docs/` – Документация MkDocs, поставляемая на PyPI; подходящее место для дополнительных руководств.
* `tests/` – Наборы тестов Pytest и unittest, которые импортируют примеры, проверяют конвертеры, градиенты, точки и утилиты интернационализации.

## Публичный API (`src/drawzero/__init__.py`)

Пакет предоставляет "плоский" API, предназначенный для имитации эргономики turtle/pygame zero. Все утилиты рисования импортируются из `utils.draw`, а математические утилиты — из соседних модулей:

* Графические примитивы: `line`, `circle`, `rect`, `polygon`, `text`, `image` и т.д.
* Заполненные варианты используют те же точки входа рендерера, передавая `line_width=0`.
* Утилиты для анимации и времени: `tick`, `sleep`, `run`, `fps`, `quit`.
* Утилиты ввода проксируют состояние клавиатуры/мыши рендерера (`get_keys_pressed`, `keysdown`, `mousebuttonsdown`, ...).
* Утилиты: `Pt` (гибрид вектора/черепахи), `Gradient`, `copy_examples`, константы цветов (`C`, `COLORS`, `ALL_COLORS`).

Каждая функция, предназначенная для пользователя, в конечном итоге проходит через стек рендерера, описанный ниже.

## Конвейер рендеринга (`utils.draw` → `utils.renderer`)

`utils.draw` выполняет проверку и приведение типов аргументов перед делегированием фактическому бэкенду рисования. Общие шаги для каждого примитива:

1. Преобразование данных, предоставленных пользователем, с помощью утилит-конвертеров (`utils.converters`). Эти функции нормализуют координаты, радиусы, прямоугольники и цвета, собирая при этом подробные сообщения об ошибках через `BadDrawParmsError` и локализованные строки в `utils.i18n`.
2. Выбор модуля бэкенда в зависимости от переменной окружения `EJUDGE_MODE`. Сборки с GUI импортируют `utils.renderer` (на основе pygame). Сборки в текстовом режиме/CI возвращаются к `utils.renderer_ejudge`, который выводит команды для автоматизированных судей.
3. После вызова рендерера обновить кэшированные списки событий ввода, чтобы потребители видели положения мыши/клавиш в логических (виртуальных) координатах.

### `utils.renderer`

Рендерер pygame лениво создает окно с изменяемым размером и хранит его копию вне экрана, чтобы пережить изменение размера. Важные обязанности:

* Управление поверхностью: `_create_surface()` откладывает создание окна до первого вызова рисования; `_resize()` перемасштабирует существующее содержимое, когда SDL генерирует событие изменения размера.
* Рисование примитивов: каждая функция `draw_*` обрабатывает необязательное альфа-смешивание путем рисования во временных буферах `pygame.Surface` при необходимости.
* Насос событий: `draw_tick()` продвигает часы (цель 30 FPS), очищает очередь событий и заполняет глобальные списки (`keysdown`, `mousebuttonsdown` и т.д.), используемые `utils.draw`.
* Хуки жизненного цикла: `atexit.register(_draw_go)` поддерживает цикл pygame в рабочем состоянии до завершения процесса; `_init()` настраивает осведомленность о DPI в Windows и центрирует окно.
* Масштабирование координат: функции-сеттеры из `utils.screen_size` поддерживают сопоставление между "виртуальными" координатами 1000×1000 (используемыми API) и фактическим размером окна.

### `utils.renderer_ejudge`

Облегченная заглушка, используемая, когда `EJUDGE_MODE=true` (например, тесты, работающие без GUI). Он зеркально отражает API рендерера, но просто выводит сериализованные команды рисования. Размер экрана фиксирован на 1000×1000, поэтому преобразование координат остается согласованным.

## Преобразования координат (`utils.screen_size`)

DrawZero всегда предоставляет виртуальный холст 1000×1000. `set_virtual_size()` может изменить это логическое разрешение, а `set_real_size()` вызывается рендерером, когда он знает реальный размер в пикселях. Модуль предоставляет утилиты для преобразования между пространствами координат:

* `to_canvas_x` / `to_canvas_y` – преобразование виртуальных координат в фактические пиксели.
* `from_canvas_x` / `from_canvas_y` – преобразование обратно в логические координаты (используется при сообщении о положениях мыши).

Все конвертеры и обертки событий полагаются на этот модуль, поэтому настраивайте его осторожно, если поддерживаете неквадратные холсты.

## Математические и вспомогательные утилиты

* `utils.pt.Pt` реализует изменяемый 2D-вектор с движением в стиле черепахи, арифметическими операторами и удобными методами (`forward`, `rotate_around`, `distance` и т.д.). Примеры полагаются на него для логики анимации.
* `utils.gradient.Gradient` создает цветовые пандусы в числовой области (по умолчанию 0–1). Он использует ту же инфраструктуру конвертера/ошибок для обеспечения последовательной проверки.
* `utils.colors` предоставляет цветовую таблицу pygame как через доступ к атрибутам (`C.red`), так и через словари (`COLORS`, `ALL_COLORS`).
* `utils.key_flags` зеркально отражает константы клавиш pygame, поэтому код может использовать `K.<name>`, даже когда pygame отсутствует (константы загружаются лениво, когда доступны).
* `utils.copy_examples.copy_examples()` копирует `src/drawzero/examples` в текущий рабочий каталог; точка входа CLI вызывает его для начальной настройки для учащихся.

## Примеры (`src/drawzero/examples`)

Короткие двуязычные скрипты демонстрируют API: примитивы рисования, циклы, анимации, градиенты, изображения и простые интерактивные игры. Тесты импортируют многие из них, чтобы убедиться, что они все еще выполняются, поэтому держите побочные эффекты (например, бесконечные циклы) за защитными блоками, если вы добавляете новые.

## Тесты (`tests/`)

* `test_examples_gui_mode.py` импортирует каждый модуль примера, чтобы убедиться, что он работает с реальным рендерером.
* `test_examples_text_mode.py` устанавливает `EJUDGE_MODE` и утверждает, что пути текстового рендерера работают.
* Остальные модули pytest охватывают конкретные утилиты: проверку конвертера, локализованные сообщения об ошибках, интерполяцию градиента, API вектора `Pt` и поведение `copy_examples()`.

Используйте эти тесты в качестве справочных материалов при расширении логики проверки или добавлении новых примитивов.
