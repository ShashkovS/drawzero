# Ввод с клавиатуры и мыши

Эта страница объясняет, как считывать ввод с клавиатуры и мыши при создании
интерактивного рисунка с помощью DrawZero. Она использует простой язык и много примеров, чтобы
вы могли понять каждый шаг.

## Зачем нам нужен цикл событий

Программы реального времени должны проверять наличие новых событий много раз в секунду. Вы можете увидеть
этот шаблон почти в каждой игре или анимации. Основной цикл выглядит так:

```python
while True:
    tick()          # обновляем анимацию, таймеры, физику
    # обрабатываем события # здесь считываем состояние клавиатуры и мыши
```

`tick()` взят из утилит DrawZero (см. страницу [Основы анимации](animation.md)
). Он продвигает время и просит рендерер собрать новые события ввода. После
каждого `tick()` вы можете безопасно считывать списки клавиатуры и мыши, описанные на этой
странице.

Если вы перестанете вызывать `tick()`, окно замерзнет, и новые данные ввода не поступят.
Вот почему вы должны поддерживать работу цикла, даже когда ничего не происходит.

## Понимание утилит ввода

Рендерер записывает два вида информации:

1. **Текущее состояние** – какие клавиши или кнопки мыши нажаты прямо сейчас.
2. **Очереди событий** – история того, что изменилось за последний кадр.

Утилиты состояния хороши для непрерывных действий (например, удержание левой
стрелки для перемещения спрайта). Очереди событий лучше подходят, когда вам нужны одноразовые действия
(например, обнаружение однократного нажатия клавиши для открытия меню).

Все утилиты находятся в глобальном объекте `renderer`. Импортируйте их из
`drawzero.renderer` или обращайтесь к ним через `utils.draw` в зависимости от выбранного вами
стиля скрипта (см. [Обзор архитектуры](architecture.md)).

### Утилиты для получения снимка состояния

#### `get_keys_pressed = renderer.get_keys_pressed`

Возвращает **набор строк** с именами всех клавиш, которые в данный момент удерживаются
нажатыми. Используйте его, когда вас волнует только то, нажата ли клавиша, а не то, сколько раз она была
нажата.

```python
from drawzero.renderer import get_keys_pressed

pressed = get_keys_pressed()
if "LEFT" in pressed:
    player_x -= 5
if "SPACE" in pressed:
    player_jump()
```

`get_keys_pressed()` пересчитывается при каждом вызове, поэтому запрашивайте его **после**
`tick()`. Он использует те же имена клавиш, которые появляются в очередях событий, описанных
ниже.

#### `keys_mods_pressed = renderer.keys_mods_pressed`

Возвращает **набор имен модификаторов**, таких как `"SHIFT"`, `"CTRL"` или `"ALT"`. Это
полезно, когда вы хотите поддерживать сочетания клавиш, такие как `Ctrl+S`.

```python
if "CTRL" in keys_mods_pressed() and "S" in get_keys_pressed():
    save_project()
```

Модификаторы отделены от обычных клавиш, поэтому вы можете быстро их проверить, не
выполняя поиск по всему набору клавиш.

#### `get_mouse_pressed = renderer.get_mouse_pressed`

Возвращает **набор имен кнопок мыши**, таких как `"LEFT"`, `"MIDDLE"` и
`"RIGHT"`. Комбинируйте его с текущим положением мыши из ваших утилит холста
(см. [Графические примитивы](primitives.md) для утилит координат).

```python
if "LEFT" in get_mouse_pressed():
    draw_circle(mouse_pos(), radius=10)
```

Помните: это сообщает только о кнопках, которые удерживаются в последнем кадре. Вам
все еще нужны очереди событий, чтобы определить точный момент щелчка.

### Очереди событий

Очереди событий — это списки, которые сбрасываются при каждом `tick()`. Они сохраняют порядок
входящих событий, чтобы вы могли воспроизвести то, что произошло за последний кадр.

Каждый элемент в очереди — это небольшой объект (обычно `namedtuple` или
простой класс) с полями, такими как `key`, `mod`, `button`, `pos` или `rel`. Вы можете
изучить их с помощью `print(event)`, чтобы узнать точную структуру.

#### `keysdown = renderer.keysdown`

Содержит **список событий нажатия клавиш**. Каждое событие срабатывает, когда клавиша переходит из
состояния "отпущена" в "нажата". Используйте его для одиночных нажатий.

```python
for event in keysdown:
    if event.key == "SPACE":
        spawn_bullet()
```

Эта очередь пуста, если в текущем кадре не было новых нажатий клавиш.

#### `keysup = renderer.keysup`

Содержит **список событий отпускания клавиш**. Эти события срабатывают, когда клавиша
отпускается. Они полезны для переключателей или для прекращения действия именно тогда, когда игрок
отпускает клавишу.

```python
for event in keysup:
    if event.key == "LEFT":
        stop_moving()
```

#### `mousemotions = renderer.mousemotions`

Содержит **список событий движения мыши**. Каждое событие имеет как минимум атрибут `pos`
с текущим положением курсора в логических (виртуальных) координатах и,
как правило, атрибут `rel` с дельтой движения.

```python
for event in mousemotions:
    trail.add_point(event.pos)
```

Прочтите [Изображения и системы координат](images.md), чтобы узнать, как логические позиции
соотносятся с вашим холстом.

#### `mousebuttonsdown = renderer.mousebuttonsdown`

Содержит **список событий нажатия кнопок мыши**. Они срабатывают, когда пользователь нажимает
любую кнопку мыши. События включают имя кнопки и положение мыши.

```python
for event in mousebuttonsdown:
    if event.button == "LEFT":
        start_drag(event.pos)
```

#### `mousebuttonsup = renderer.mousebuttonsup`

Содержит **список событий отпускания кнопок мыши**. Они срабатывают, когда пользователь отпускает
любую кнопку мыши. Используйте их для завершения действий, таких как рисование линии или подтверждение
выбора.

```python
for event in mousebuttonsup:
    if event.button == "LEFT":
        end_drag(event.pos)
```

## Собираем все вместе

Вот полный цикл, который использует как утилиты состояния, так и утилиты событий.

```python
from drawzero import renderer
from drawzero import utils

while True:
    utils.tick()

    # непрерывное движение
    pressed = renderer.get_keys_pressed()
    if "LEFT" in pressed:
        player.move(-5, 0)
    if "RIGHT" in pressed:
        player.move(5, 0)

    # одноразовые действия
    for event in renderer.keysdown:
        if event.key == "SPACE":
            player.jump()

    for event in renderer.mousebuttonsdown:
        if event.button == "LEFT":
            player.shoot(event.pos)

    # обновите холст здесь (см. Основы анимации для вызовов рисования)
```

Вы можете сравнить этот шаблон с примером `16_keyboard_and_mouse.py`, указанным
в [Обзоре примеров](examples_overview.md). Этот скрипт также демонстрирует,
как комбинировать ввод с клавиатуры с обратной связью на экране.

## Советы по плавному взаимодействию

- Регулярно вызывайте `tick()`. Типичная анимация DrawZero работает 30 раз в
  секунду, но утилиты работают на любой скорости.
- Избегайте длительного блокирующего кода (например, `time.sleep(5)`) внутри цикла. При необходимости
  разбивайте тяжелую работу на небольшие части или фоновые потоки.
- Если вам нужно только последнее положение мыши, сохраняйте последний элемент из
  `mousemotions` или используйте утилиты, такие как `utils.draw.mouse_pos()`.
- Всегда тестируйте на реальном оборудовании. Тачпады, игровые мыши и клавиатуры с
  нераскладками, отличными от английской, могут отправлять разные имена кнопок. Распечатывайте события во время
  разработки, чтобы увидеть фактические данные.
- Комбинируйте проверки модификаторов (`keys_mods_pressed`) с обычными клавишами для создания
  сочетаний клавиш, которые кажутся пользователям естественными.

## Где узнать больше

- [Основы анимации](animation.md) объясняет, как `tick()` вписывается в
  конвейер рисования.
- [Обзор архитектуры](architecture.md) показывает, как утилиты ввода подключаются к
  внутренним компонентам рендерера.
- [Обзор примеров](examples_overview.md) указывает на готовые скрипты, которые вы можете
  запускать и изменять.
- Изображение `keyboard_and_mouse_events.gif` в папке docs дает быстрый
  визуальный предварительный просмотр того, что вы можете создать.

С помощью этих инструментов вы можете надежно захватывать события клавиатуры и мыши и создавать
отзывчивые, интерактивные сцены в DrawZero.
